"use strict";(self.webpackChunklukso_docs=self.webpackChunklukso_docs||[]).push([[8350],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return f}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=s(n),f=r,y=p["".concat(l,".").concat(f)]||p[f]||u[f]||o;return n?a.createElement(y,i(i({ref:t},d),{},{components:n})):a.createElement(y,i({ref:t},d))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1188:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],c={sidebar_label:"Writing Data",sidebar_position:4},l="Writing Data",s={unversionedId:"tools/erc725js/writing-data",id:"tools/erc725js/writing-data",title:"Writing Data",description:"How to write data to the ERC725Account key-value store?",source:"@site/docs/tools/erc725js/writing-data.md",sourceDirName:"tools/erc725js",slug:"/tools/erc725js/writing-data",permalink:"/tools/erc725js/writing-data",editUrl:"https://github.com/lukso-network/docs/tree/main/docs/tools/erc725js/writing-data.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"Writing Data",sidebar_position:4},sidebar:"toolsSidebar",previous:{title:"Providers",permalink:"/tools/erc725js/providers"},next:{title:"ERC725",permalink:"/tools/erc725js/classes/ERC725"}},d={},u=[{value:"How to write data to the ERC725Account key-value store?",id:"how-to-write-data-to-the-erc725account-key-value-store",level:4},{value:"Example Flow",id:"example-flow",level:2}],p={toc:u};function f(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"writing-data"},"Writing Data"),(0,o.kt)("h4",{id:"how-to-write-data-to-the-erc725account-key-value-store"},"How to write data to the ERC725Account key-value store?"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"erc725.js")," library cannot write or relay data to the blockchain. However, developers can use its utility methods to prepare data for writing to the blockchain. This section will provide an guide for using such functionality."),(0,o.kt)("h2",{id:"example-flow"},"Example Flow"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Encode the data using the ",(0,o.kt)("inlineCode",{parentName:"li"},"encodeData")," function."),(0,o.kt)("li",{parentName:"ol"},"Flatten the encoded data using the ",(0,o.kt)("inlineCode",{parentName:"li"},"flattenEncodedData")," function."),(0,o.kt)("li",{parentName:"ol"},"Get a ABI (JSON Interface) of the desired contract, in order to reference it."),(0,o.kt)("li",{parentName:"ol"},"Iterate on ",(0,o.kt)("inlineCode",{parentName:"li"},"flattenedData")," and call ",(0,o.kt)("inlineCode",{parentName:"li"},"setData")," on the contract.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Extend instantiation of the contract"),(0,o.kt)("br",null),(0,o.kt)("p",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Instantiation"',title:'"Instantiation"'},"import Web3 from 'web3';\nimport { ERC725 } from '@erc725/erc725.js';\n\nexport const schemas = [\n  {\n    name: 'SupportedStandards:LSP3UniversalProfile',\n    key: '0xeafec4d89fa9619884b6b89135626455000000000000000000000000abe425d6',\n    keyType: 'Mapping',\n    valueContent: '0xabe425d6',\n    valueType: 'bytes',\n  },\n  {\n    name: 'LSP3Profile',\n    key: '0x5ef83ad9559033e6e941db7d7c495acdce616347d28e90c7ce47cbfcfcad3bc5',\n    keyType: 'Singleton',\n    valueContent: 'JSONURL',\n    valueType: 'bytes',\n  },\n  {\n    name: 'LSP1UniversalReceiverDelegate',\n    key: '0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47',\n    keyType: 'Singleton',\n    valueContent: 'Address',\n    valueType: 'address',\n  },\n  {\n    name: 'LSP3IssuedAssets[]',\n    key: '0x3a47ab5bd3a594c3a8995f8fa58d0876c96819ca4516bd76100c92462f2f9dc0',\n    keyType: 'Array',\n    valueContent: 'Address',\n    valueType: 'address',\n  },\n];\n\nconst address = '0x0c03fba782b07bcf810deb3b7f0595024a444f4e';\nconst provider = new Web3.providers.HttpProvider(\n  'https://rpc.l14.lukso.network',\n);\nconst config = {\n  ipfsGateway: 'https://ipfs.lukso.network/ipfs/',\n};\n\nconst myERC725 = new ERC725(schemas, address, provider, config);\n")))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// 1. Encode the data using the `encodeData` function.\nconst encodedData = myERC725.encodeData({\n  LSP3Profile: {\n    hashFunction: 'keccak256(utf8)',\n    hash: '0x820464ddfac1bec070cc14a8daf04129871d458f2ca94368aae8391311af6361',\n    url: 'ifps://QmYr1VJLwerg6pEoscdhVGugo39pa6rycEZLjtRPDfW84UAx',\n  },\n  'LSP3IssuedAssets[]': [\n    '0xD94353D9B005B3c0A9Da169b768a31C57844e490',\n    '0xDaea594E385Fc724449E3118B2Db7E86dFBa1826',\n  ],\n  LSP1UniversalReceiverDelegate: '0x1183790f29BE3cDfD0A102862fEA1a4a30b3AdAb',\n});\n\n// 2. Flatten the encoded data using the `flattenEncodedData` function.\nconst dataToSaveOnChain = flattenEncodedData(encodedDataManyKeys);\n\n// 3. Get an ABI (JSON Interface) of the desired contract, in order to reference it.\nconst erc725Contract = new web3.eth.Contract(\n  [\n    // NOTE: We are not loading the full contract ABI, only the function we need\n    {\n      inputs: [\n        {\n          internalType: 'bytes32',\n          name: '_key',\n          type: 'bytes32',\n        },\n        {\n          internalType: 'bytes',\n          name: '_value',\n          type: 'bytes',\n        },\n      ],\n      name: 'setData',\n      outputs: [],\n      stateMutability: 'nonpayable',\n      type: 'function',\n    },\n  ],\n  ERC725_ADDRESS, // replace this with the desired value\n);\n\n// 4. Iterate on `flattenedData` and call `setData` on the smart contract.\nawait Promise.all(\n  dataToSaveOnChain.map(async ({ key, value }) => {\n    return erc725Contract.methods.setData(key, value).send();\n  }),\n);\n")))}f.isMDXComponent=!0}}]);