"use strict";(self.webpackChunklukso_docs=self.webpackChunklukso_docs||[]).push([[410],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return u}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),k=p(a),u=r,c=k["".concat(s,".").concat(u)]||k[u]||d[u]||o;return a?n.createElement(c,i(i({ref:t},m),{},{components:a})):n.createElement(c,i({ref:t},m))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=k;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},769:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return d}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),i=["components"],l={},s="Validating at LUKSO",p={unversionedId:"networks/validator_node",id:"networks/validator_node",title:"Validating at LUKSO",description:"Terminology",source:"@site/docs/networks/validator_node.md",sourceDirName:"networks",slug:"/networks/validator_node",permalink:"/networks/validator_node",editUrl:"https://github.com/lukso-network/docs/tree/main/docs/networks/validator_node.md",tags:[],version:"current",frontMatter:{},sidebar:"networksSidebar",previous:{title:"Backup And Recover Your validator",permalink:"/networks/how_to_backup_and_recover_your_node"}},m={},d=[{value:"Terminology",id:"terminology",level:2},{value:"Validator Node",id:"validator-node",level:3},{value:"Validator Keystore",id:"validator-keystore",level:3},{value:"Validator Key",id:"validator-key",level:3},{value:"Validator Key State",id:"validator-key-state",level:3},{value:"How <strong>Validator Keys</strong> are created",id:"how-validator-keys-are-created",level:2},{value:"An Example",id:"an-example",level:3},{value:"Node Setup Example",id:"node-setup-example",level:3}],k={toc:d};function u(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"validating-at-lukso"},"Validating at LUKSO"),(0,o.kt)("h2",{id:"terminology"},"Terminology"),(0,o.kt)("h3",{id:"validator-node"},"Validator Node"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Validator Node")," is a combination of services and an underlying keystore that if run together are\nsyncing, validating and proposing blocks. In most cases it can be described as a directory that contains",(0,o.kt)("br",{parentName:"p"}),"\n","all necessary information to ",(0,o.kt)("em",{parentName:"p"},"run")," this node. At LUKSO the directory has this following structure"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"configs"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"configs.yaml"),"   // configuration of consensus service"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"genesis.json"),"   // configuration of execution service"))),(0,o.kt)("li",{parentName:"ul"},"data",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"execution_data"),"   // db of execution service"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"consensus_data"),"   // db of consensus service"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"validator_data"),"   // db of validator service"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"keystore")," ",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"prysm/direct/account/all-accounts.keystore.json"),"     // keystore of valdiator keys"),(0,o.kt)("li",{parentName:"ul"},"..."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"password.txt"),"        // password of keystore"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"docker-compose.yaml")," // describes how to run the docker images"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"node_config.yaml"),"   // adjustable values on how to run the nodes"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},".env"),"   // auto genrated file derived from ",(0,o.kt)("strong",{parentName:"li"},"node_config.yaml"))),(0,o.kt)("h3",{id:"validator-keystore"},"Validator Keystore"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystore")," is a directory with private key in formats for the respective validator service\nversion (Teku, Lighthouse, Prysm,...). The keystore has a fixed number of keys. If you need to change\nthe number of keys you ",(0,o.kt)("strong",{parentName:"p"},"must")," create a new keystore. There is always ",(0,o.kt)("strong",{parentName:"p"},"one")," ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystore")," for\none ",(0,o.kt)("strong",{parentName:"p"},"Validator Node")),(0,o.kt)("h3",{id:"validator-key"},"Validator Key"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"Validator Key")," is a private key that can have an active balance and is used to sign attestations\nand proposed blocks. The key can have an arbitrary amount of staked LYX but it ",(0,o.kt)("strong",{parentName:"p"},"won't")," change the reward.\nIt is possible to deposit LYX multiple time for this key and that is important for the case the ",(0,o.kt)("strong",{parentName:"p"},"Validator Key")," missed\nduties and lost balance."),(0,o.kt)("h3",{id:"validator-key-state"},"Validator Key State"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"Validator Key State")," is the state of one particular key. A ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystore")," can have many\nkeys being in many states. When firstly created all the ",(0,o.kt)("strong",{parentName:"p"},"Validator Keys")," are in the state\nNOT_DEPOSITED. (NOTE: If the keystore was recreated the state my differ for some keys)"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"State"),(0,o.kt)("th",{parentName:"tr",align:null},"Acitvated By"),(0,o.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"NOT_DEPOSITED"),(0,o.kt)("td",{parentName:"tr",align:null},"..."),(0,o.kt)("td",{parentName:"tr",align:null},"The keystore was created for the first time")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"PENDING"),(0,o.kt)("td",{parentName:"tr",align:null},"a deposit with ",(0,o.kt)("em",{parentName:"td"},"min staking amount")," was made"),(0,o.kt)("td",{parentName:"tr",align:null},"There is a proven stake deposited in the Deposit Contract")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"ACTIVE"),(0,o.kt)("td",{parentName:"tr",align:null},"The deposit was observed by the consensus network"),(0,o.kt)("td",{parentName:"tr",align:null},"the validator is eligible to be selected to propose and attest in the upcoming epochs")))),(0,o.kt)("h2",{id:"how-validator-keys-are-created"},"How ",(0,o.kt)("strong",{parentName:"h2"},"Validator Keys")," are created"),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"Validator Key")," is always part of a ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystore")," - as a single key or a combination of many. The keys\nare being derived by a ",(0,o.kt)("a",{parentName:"p",href:"https://wolovim.medium.com/ethereum-201-mnemonics-bb01a9108c38"},"Mnemonic"),".\nA Mnemonic can potentially create an infinite amount of keys. It is important to understand that\nthese keys are indexed. There is a possibility to (theoretically) create a certain range."),(0,o.kt)("p",null,"Once a mnemonic is known the creation of ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystores")," is ",(0,o.kt)("strong",{parentName:"p"},"not")," random but ",(0,o.kt)("strong",{parentName:"p"},"deterministic"),"."),(0,o.kt)("h3",{id:"an-example"},"An Example"),(0,o.kt)("p",null,"Given a mnemonic ",(0,o.kt)("em",{parentName:"p"},"m"),". We create a keystore from position 0 to 2. This could result into"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Keystore A",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Key0: 0x8154..12"),(0,o.kt)("li",{parentName:"ul"},"Key1: 0x7361..45"),(0,o.kt)("li",{parentName:"ul"},"Key2: 0x7481..fe")))),(0,o.kt)("p",null,"Now let's assume we deleted this keystore, and we create a new one from position 1 to 3. This results into"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Keystore B",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Key1: 0x7361..45"),(0,o.kt)("li",{parentName:"ul"},"Key2: 0x7481..fe"),(0,o.kt)("li",{parentName:"ul"},"Key3: 0x78ca..89")))),(0,o.kt)("p",null,"As you can see the Key1 and Key2 are the sane in ",(0,o.kt)("strong",{parentName:"p"},"Keystore A")," and ",(0,o.kt)("strong",{parentName:"p"},"Keystore B"),". This mechanism\nallows for great power to rearrange your node setup."),(0,o.kt)("h3",{id:"node-setup-example"},"Node Setup Example"),(0,o.kt)("p",null,"Let's assume - given a mnemonic ",(0,o.kt)("em",{parentName:"p"},"m")," - we want to create 2 nodes with 30 keys in\n",(0,o.kt)("strong",{parentName:"p"},"Node A")," and 16 keys in the other ",(0,o.kt)("strong",{parentName:"p"},"Node B"),".  Given our mnemonic ",(0,o.kt)("em",{parentName:"p"},"m")," we would\ne.g. have the following setup:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Node A")," has a keystore with keys from position ",(0,o.kt)("em",{parentName:"p"},"0")," to position ",(0,o.kt)("em",{parentName:"p"},"29"),"\n",(0,o.kt)("strong",{parentName:"p"},"Node B")," has a keystore with keys from position ",(0,o.kt)("em",{parentName:"p"},"30")," to position ",(0,o.kt)("em",{parentName:"p"},"45")),(0,o.kt)("p",null,"Now let's assume we want to rearrange the ",(0,o.kt)("strong",{parentName:"p"},"Validator Keys"),"'s by having an equal amount of keys on both nodes."),(0,o.kt)("p",null,"We should:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Stop the validator nodes"),(0,o.kt)("li",{parentName:"ol"},"Delete the keystores"),(0,o.kt)("li",{parentName:"ol"},"Recreate the keystores with the same mnemonic ",(0,o.kt)("strong",{parentName:"li"},"m")),(0,o.kt)("li",{parentName:"ol"},"Start the nodes again")),(0,o.kt)("p",null,"The setup could be"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Node A")," has a keystore with keys from position ",(0,o.kt)("em",{parentName:"p"},"0")," to position ",(0,o.kt)("em",{parentName:"p"},"22"),"\n",(0,o.kt)("strong",{parentName:"p"},"Node B")," has a keystore with keys from position ",(0,o.kt)("em",{parentName:"p"},"23")," to position ",(0,o.kt)("em",{parentName:"p"},"45")))}u.isMDXComponent=!0}}]);