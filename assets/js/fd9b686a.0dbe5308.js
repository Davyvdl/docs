"use strict";(self.webpackChunklukso_docs=self.webpackChunklukso_docs||[]).push([[410],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return k}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(a),k=r,c=m["".concat(s,".").concat(k)]||m[k]||u[k]||o;return a?n.createElement(c,i(i({ref:t},d),{},{components:a})):n.createElement(c,i({ref:t},d))}));function k(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},769:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return k},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),i=["components"],l={},s="Validating on LUKSO",p={unversionedId:"networks/validator_node",id:"networks/validator_node",title:"Validating on LUKSO",description:"Terminology",source:"@site/docs/networks/validator_node.md",sourceDirName:"networks",slug:"/networks/validator_node",permalink:"/networks/validator_node",editUrl:"https://github.com/lukso-network/docs/tree/main/docs/networks/validator_node.md",tags:[],version:"current",frontMatter:{},sidebar:"networksSidebar",previous:{title:"L14 Public Testnet",permalink:"/networks/l14-testnet"}},d={},u=[{value:"Terminology",id:"terminology",level:2},{value:"Validator Node",id:"validator-node",level:3},{value:"Validator Keystore",id:"validator-keystore",level:3},{value:"Validator Keystore",id:"validator-keystore-1",level:3},{value:"Validator Key State",id:"validator-key-state",level:3},{value:"How <strong>Validator Keys</strong> are created",id:"how-validator-keys-are-created",level:2},{value:"An Example",id:"an-example",level:3},{value:"Node Setup Example",id:"node-setup-example",level:3}],m={toc:u};function k(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"validating-on-lukso"},"Validating on LUKSO"),(0,o.kt)("h2",{id:"terminology"},"Terminology"),(0,o.kt)("h3",{id:"validator-node"},"Validator Node"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Validator Node")," is a combination of services and an underlying keystore that if run together are\nsyncing, validating and proposing blocks. In most cases it can be described as a directory tha  all\nnecessary information to ",(0,o.kt)("em",{parentName:"p"},"run")," this node. At LUKSO the directory has this structure"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"configs",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"configs.yaml   // configuration of consensus service"),(0,o.kt)("li",{parentName:"ul"},"genesis.json   // configuration of execution service"))),(0,o.kt)("li",{parentName:"ul"},"data",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"execution_data   // db of execution service"),(0,o.kt)("li",{parentName:"ul"},"consensus_data   // db of consensus service"),(0,o.kt)("li",{parentName:"ul"},"validator_data   // db of validator service"))),(0,o.kt)("li",{parentName:"ul"},"keystore ",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"prysm/direct/account/all-accounts.keystore.json     // keystore of valdiator keys"),(0,o.kt)("li",{parentName:"ul"},"..."),(0,o.kt)("li",{parentName:"ul"},"password.txt        // password of keystore"))),(0,o.kt)("li",{parentName:"ul"},"docker-compose.yaml // describes how to run the docker images"),(0,o.kt)("li",{parentName:"ul"},"node_config.yaml   // adjustable values on how to run the nodes")),(0,o.kt)("h3",{id:"validator-keystore"},"Validator Keystore"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystore")," is a directory with private key in formats for the respective validator service\nversion (Teku, Lighthouse, Prysm,...). The keystore has a fixed number of keys. If you need to change\nthe number of keys -> a new keystore ",(0,o.kt)("strong",{parentName:"p"},"must")," be created. There is always one ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystore")," for\none ",(0,o.kt)("strong",{parentName:"p"},"Validator Node")),(0,o.kt)("h3",{id:"validator-keystore-1"},"Validator Keystore"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"Validator Key")," is one private key that can have an active balance and is used to sign attestations\nand proposed blocks. The key can have an arbitrary amount of staked LYX but it ",(0,o.kt)("strong",{parentName:"p"},"won't")," change the reward.\nIt is possible to deposit multiple time and that is important for the case the ",(0,o.kt)("strong",{parentName:"p"},"Validator Key")," missed\nduties and lost balance."),(0,o.kt)("h3",{id:"validator-key-state"},"Validator Key State"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"Validator Key State")," is the state of one particular key. A ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystore")," can have many\ndifferent keys in many different states. When firstly created all the ",(0,o.kt)("strong",{parentName:"p"},"Validator Keys")," are in the state\nNOT_DEPOSITED. (NOTE: If the keystore was recreated the state my differ for some keys)"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"State"),(0,o.kt)("th",{parentName:"tr",align:null},"Acitvated By"),(0,o.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"NOT_DEPOSITED"),(0,o.kt)("td",{parentName:"tr",align:null},"..."),(0,o.kt)("td",{parentName:"tr",align:null},"The keystore was created for the first time")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"PENDING"),(0,o.kt)("td",{parentName:"tr",align:null},"a deposit with ",(0,o.kt)("em",{parentName:"td"},"min staking amount")," was made"),(0,o.kt)("td",{parentName:"tr",align:null},"There is a proven stake deposited in the Deposit Contract")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"ACTIVE"),(0,o.kt)("td",{parentName:"tr",align:null},"The deposit was observed by the consensus network"),(0,o.kt)("td",{parentName:"tr",align:null},"the validator is eligible to be selected to propose and attest in the upcoming epochs")))),(0,o.kt)("h2",{id:"how-validator-keys-are-created"},"How ",(0,o.kt)("strong",{parentName:"h2"},"Validator Keys")," are created"),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"Validator Key")," is always part of a ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystore")," - as a single key or a combination of many. The keys\nare being derived by a ",(0,o.kt)("a",{parentName:"p",href:"https://wolovim.medium.com/ethereum-201-mnemonics-bb01a9108c38"},"Mnemonic"),".\nA Mnemonic can potentially create and infinite amount of keys. It is important to understand that\nthese keys are indexed. There is a possibility to (theoretically) create a certain section of the key range."),(0,o.kt)("p",null,"Once a mnemonic is known the creation of ",(0,o.kt)("strong",{parentName:"p"},"Validator Keystores")," is not random but deterministic."),(0,o.kt)("h3",{id:"an-example"},"An Example"),(0,o.kt)("p",null,"Given a mnemonic ",(0,o.kt)("em",{parentName:"p"},"m"),". We create a keystore from position 0 to 2. This could result into"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Keystore A",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Key0: 0x8154..12"),(0,o.kt)("li",{parentName:"ul"},"Key1: 0x7361..45"),(0,o.kt)("li",{parentName:"ul"},"Key2: 0x7481..fe")))),(0,o.kt)("p",null,"Now lets assume we deleted this keystore and we create a new one from position 1 to 3. This results into"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Keystore B",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Key1: 0x7361..45"),(0,o.kt)("li",{parentName:"ul"},"Key2: 0x7481..fe"),(0,o.kt)("li",{parentName:"ul"},"Key3: 0x78ca..89")))),(0,o.kt)("p",null,"As you can see the Key1 and Key2 are the sane in ",(0,o.kt)("strong",{parentName:"p"},"Keystore A")," and ",(0,o.kt)("strong",{parentName:"p"},"Keystore B"),". This mechanism\nallows for great power to rearrange your node setup."),(0,o.kt)("h3",{id:"node-setup-example"},"Node Setup Example"),(0,o.kt)("p",null,"Lets assume we want to create 2 nodes with 30 keys in ",(0,o.kt)("strong",{parentName:"p"},"Node A")," and 16 keys in the other ",(0,o.kt)("strong",{parentName:"p"},"Node B"),".\nGiven our mnemonic ",(0,o.kt)("em",{parentName:"p"},"m")," we would most likely have the following setup:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Node A")," has a keystore with keys from position 0 to position 29\n",(0,o.kt)("strong",{parentName:"p"},"Node B")," has a keystore with keys from position 30 to position 45"),(0,o.kt)("p",null,"Now lets we want to rearrange by having an equal amount of keys on both nodes."),(0,o.kt)("p",null,"We could:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Stop the validator nodes"),(0,o.kt)("li",{parentName:"ol"},"Delete the keystores"),(0,o.kt)("li",{parentName:"ol"},"Recreate the keystores with the same mnemonic ",(0,o.kt)("strong",{parentName:"li"},"m")),(0,o.kt)("li",{parentName:"ol"},"Start the nodes again")),(0,o.kt)("p",null,"The setup could be"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Node A")," has a keystore with keys from position 0 to position 22\n",(0,o.kt)("strong",{parentName:"p"},"Node B")," has a keystore with keys from position 23 to position 45"))}k.isMDXComponent=!0}}]);